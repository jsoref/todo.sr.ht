// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"git.sr.ht/~sircmpwn/core-go/model"
)

type Entity interface {
	IsEntity()
}

type EventDetail interface {
	IsEventDetail()
}

// A cursor for enumerating access control list entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ACLCursor struct {
	Results []*TrackerACL `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

type ACLInput struct {
	// Permission to view tickets
	Browse bool `json:"browse"`
	// Permission to submit tickets
	Submit bool `json:"submit"`
	// Permission to comment on tickets
	Comment bool `json:"comment"`
	// Permission to edit tickets
	Edit bool `json:"edit"`
	// Permission to resolve, re-open, transfer, or label tickets
	Triage bool `json:"triage"`
}

// A cursor for enumerating events
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type EventCursor struct {
	Results []*Event      `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// This is used for importing tickets from third-party services, and may only be
// used by the tracker owner. It causes a ticket submission, update, or comment
// to be attributed to an external user and appear as if it were submitted at a
// specific time.
type ImportInput struct {
	Created time.Time `json:"created"`
	// External user ID. By convention this should be "service:username", e.g.
	// "codeberg:ddevault".
	ExternalID string `json:"externalId"`
	// A URL at which the user's external profile may be found, e.g.
	// "https://codeberg.org/ddevault".
	ExternalURL string `json:"externalUrl"`
}

// A cursor for enumerating labels
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type LabelCursor struct {
	Results []*Label      `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// You may omit the status or resolution fields to leave them unchanged (or if
// you do not have permission to change them). "resolution" is required if
// status is RESOLVED.
type SubmitCommentInput struct {
	Text       string            `json:"text"`
	Status     *TicketStatus     `json:"status"`
	Resolution *TicketResolution `json:"resolution"`
	// For use by the tracker owner only
	Import *ImportInput `json:"import"`
}

type SubmitTicketInput struct {
	Subject     string     `json:"subject"`
	Body        *string    `json:"body"`
	Created     *time.Time `json:"created"`
	ExternalID  *string    `json:"externalId"`
	ExternalURL *string    `json:"externalUrl"`
}

// A cursor for enumerating subscriptions
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type SubscriptionCursor struct {
	Results []Subscription `json:"results"`
	Cursor  *model.Cursor  `json:"cursor"`
}

// A cursor for enumerating tickets
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type TicketCursor struct {
	Results []*Ticket     `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// A cursor for enumerating trackers
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type TrackerCursor struct {
	Results []*Tracker    `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// "resolution" is required if status is RESOLVED.
type UpdateStatusInput struct {
	Status     TicketStatus      `json:"status"`
	Resolution *TicketResolution `json:"resolution"`
	// For use by the tracker owner only
	Import *ImportInput `json:"import"`
}

type Version struct {
	Major int `json:"major"`
	Minor int `json:"minor"`
	Patch int `json:"patch"`
	// If this API version is scheduled for deprecation, this is the date on which
	// it will stop working; or null if this API version is not scheduled for
	// deprecation.
	DeprecationDate *time.Time `json:"deprecationDate"`
}

type AccessKind string

const (
	AccessKindRo AccessKind = "RO"
	AccessKindRw AccessKind = "RW"
)

var AllAccessKind = []AccessKind{
	AccessKindRo,
	AccessKindRw,
}

func (e AccessKind) IsValid() bool {
	switch e {
	case AccessKindRo, AccessKindRw:
		return true
	}
	return false
}

func (e AccessKind) String() string {
	return string(e)
}

func (e *AccessKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessKind", str)
	}
	return nil
}

func (e AccessKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccessScope string

const (
	AccessScopeProfile       AccessScope = "PROFILE"
	AccessScopeTrackers      AccessScope = "TRACKERS"
	AccessScopeTickets       AccessScope = "TICKETS"
	AccessScopeACLS          AccessScope = "ACLS"
	AccessScopeEvents        AccessScope = "EVENTS"
	AccessScopeSubscriptions AccessScope = "SUBSCRIPTIONS"
)

var AllAccessScope = []AccessScope{
	AccessScopeProfile,
	AccessScopeTrackers,
	AccessScopeTickets,
	AccessScopeACLS,
	AccessScopeEvents,
	AccessScopeSubscriptions,
}

func (e AccessScope) IsValid() bool {
	switch e {
	case AccessScopeProfile, AccessScopeTrackers, AccessScopeTickets, AccessScopeACLS, AccessScopeEvents, AccessScopeSubscriptions:
		return true
	}
	return false
}

func (e AccessScope) String() string {
	return string(e)
}

func (e *AccessScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessScope", str)
	}
	return nil
}

func (e AccessScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Authenticity string

const (
	// The server vouches for this information as entered verbatim by the
	// attributed entity.
	AuthenticityAuthentic Authenticity = "AUTHENTIC"
	// The server does not vouch for this information as entered by the attributed
	// entity, no authentication was provided.
	AuthenticityUnauthenticated Authenticity = "UNAUTHENTICATED"
	// The server has evidence that the information has likely been manipulated by
	// a third-party.
	AuthenticityTampered Authenticity = "TAMPERED"
)

var AllAuthenticity = []Authenticity{
	AuthenticityAuthentic,
	AuthenticityUnauthenticated,
	AuthenticityTampered,
}

func (e Authenticity) IsValid() bool {
	switch e {
	case AuthenticityAuthentic, AuthenticityUnauthenticated, AuthenticityTampered:
		return true
	}
	return false
}

func (e Authenticity) String() string {
	return string(e)
}

func (e *Authenticity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Authenticity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Authenticity", str)
	}
	return nil
}

func (e Authenticity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventType string

const (
	EventTypeCreated         EventType = "CREATED"
	EventTypeComment         EventType = "COMMENT"
	EventTypeStatusChange    EventType = "STATUS_CHANGE"
	EventTypeLabelAdded      EventType = "LABEL_ADDED"
	EventTypeLabelRemoved    EventType = "LABEL_REMOVED"
	EventTypeAssignedUser    EventType = "ASSIGNED_USER"
	EventTypeUnassignedUser  EventType = "UNASSIGNED_USER"
	EventTypeUserMentioned   EventType = "USER_MENTIONED"
	EventTypeTicketMentioned EventType = "TICKET_MENTIONED"
)

var AllEventType = []EventType{
	EventTypeCreated,
	EventTypeComment,
	EventTypeStatusChange,
	EventTypeLabelAdded,
	EventTypeLabelRemoved,
	EventTypeAssignedUser,
	EventTypeUnassignedUser,
	EventTypeUserMentioned,
	EventTypeTicketMentioned,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeCreated, EventTypeComment, EventTypeStatusChange, EventTypeLabelAdded, EventTypeLabelRemoved, EventTypeAssignedUser, EventTypeUnassignedUser, EventTypeUserMentioned, EventTypeTicketMentioned:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPublic   Visibility = "PUBLIC"
	VisibilityUnlisted Visibility = "UNLISTED"
	VisibilityPrivate  Visibility = "PRIVATE"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityUnlisted,
	VisibilityPrivate,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityUnlisted, VisibilityPrivate:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
